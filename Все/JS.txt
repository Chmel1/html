
		Нельзя создавать переменную с именем document это фатальная ошибка так как это глобальная переменная которая используется всегда
		и этим можно сломать весь код
		
		document. - специальный объект  который представляет весь HTML-документ. Благодаря нему можно работать с любыми элементами на старнице:
		изменять текст, добавлять новые элементы менять стили отслеживать события таккие как клики и многое другое.
		
		
		.previousElementSibling - свойство которое позволяет получить предыдущий элемент(соседний) относительно текущего элемента дерева DOM.
		
		
		.nextElementSibling - свойство которое позволяет получить следующий элемент(соседний) относительно текущего элемента дерева DOM.
		
		
		.parentNode - свойство которое позволяет получить текущий родительский узел для указанного элемента.Родительский узел это то где
		находится элемент.
		
		
		.childNodes - возвращает колекцию всех дочерних узлов.В том числе и \n, коментарие и подобные
		
		
		.child - как .childNodes возвращает колекцию дочерних узлов но только именно элементов без \n и подобных
		 
		 
		.querySelectorAll('') - позволяет выбрать все элементы которые соответствуют определенному CSS-селектору и вохвращает 
			их в виде статическогоNodeList(селекторы по типу 'любой тег','.example_class','#example_id')
			
			
		.querySelector('') - тоже самое что и querySelectorAll Только возвращает первый встреченый элемент 
		
		
		.closest() - позволяет найти ближайший родительский элемент (или сам элемент) который соответствуют заданному CSS-селектору
			Этот метод подниматеся по DOM-дереву от текущего элемента до смого верхнего родителя (<html>), пока не найдет элемент который соответствует селктору
			если элемент не найден то вернет null.
			
			
		.innerHTML - позволяет получить и изменить содержимое HTML-элемента 
		
		
		.outerHTML - используется для получения или замены всего HTML-кода элемента включая сам элемент и его содердимое.В отличие от .innerHTML которое
			влияет только на содержимое элемента .outerHTML затрагивает весь элемент вместе с его открыващими и закрывающими тегами
			
			
		.textContent - используется для получепния или изменения тектосвого содердимого элемента, но в отличие от .innerHtml, оно работает только с текстом
			и не учитывает HTML-теги.Это делает его особенно полезным и безопасным, когда нужно вставить текст без риска внедрения HTML-кода или скриптов.
			
			
		.nextSibling - возвращает следующий узел (node) находящийся на одном уровне вложенности с текузем узлом. Это могут быть любые типы ущлов:элементы, 
			текстовые узлы, комментарии и тд
			
			
		.createElement - основной метод для создания новых элементов в  js Он подходит для динамического создания и добавления элементов в DOM, легко 
			управляется с помощью других методов и безопасен для испольщования с пользовательскими данными.
			
			
		\\Вставка элементов в документ
			.before - удобный метод для добавления элементов или текста переде существующим элементом без прямого доступа к родителю.
			.after - Удобный метод для добавления элементов или текстка сразу полсе целевого узла, обеспечивая простоту кода и сохраняя текущею структуру DOM
			.prepend - Удобынй метод для добавления элементов или текста в начало целевого элемента позволяя быстро вставить новый контент перед другими элементами
			.append - удобный способ добавления контента в конец элемента, особенно для создания динамических обновляемых страниц.Он позволяет гибко комбинировать
				текст и HTML- элементы и хначительно упрощает процесс вставки содержимого
				
				
			Так же есть метод .insertAdjacentHTML("ПОЗИЦИЯ",Текст) - мощный метод для динамического добавлерия HTML-кода в документ, позволяющий контролировать, где именно будет 
				размещен нвоый контент относительно существующих элементов.
			.insertAdjacentText("ПОЗИЦИЯ", ТЕКСТ) - это удобный и безопасный способ добавить текстовые строки в различные места относительно целого элемента
			.insertAdjscentElement("ПОЗИЦИЯ", ЭЛЕМЕНТ) - это надежный и гибкий метод для вставки уже созданных элементов в нужное место относительно целевого элемента,
				полезен для манипуляций с DOM и управления структурой страницы
					Первый аргумент (ПОЗИЦИЯ):
									"beforebegin" - вставляет HTML непосредственно перед элементом 
									"afterbegin" - вставляет HTML в начало элемента 
									"beforeend" - вставляет HTML в конец элемента 
									"afterend" - Вставляет HTML непосредственно полсе элемента 
			
			.cloneNode(true или false) - мощный метод для создания копий элементов.Он гибок благодаря возможности копировать элементы как с дочерними элементами, так и без них.
			
			
			.appendChild - удобный метод для добавления дчоерних элементов к родительскому.Он обеспечивает гибкость при создании и добавлении новых узлов в DOM	
				а также полезен для динамического изменения и перемещения элементов на стрранице.
			
			
			.remove() - метод для удаления элемента. 
			
			
		.className - подходит для простыз операций, когда нужно задать конкретный набор классов или получить строку с существующими классами.
		
		
		.classList. - современный инструмент для управления классами HTML-элементов, предоставляющий гибкость и простоту благодаря встроенным методам.
			.add('ИМЯ КЛАССА') - добавить класс 
			.remove('ИМЯ КЛАССА') - удалить класс
			.toggle('ИМЯ КЛАССА') - если есть класс то удалить если нету то добавить
			.contains('ИМЯ КЛАССА') - если класс есть то вернет true если нету false
			.replace(('OLD ИМЯ КЛАССА','NEW 'ИМЯ КЛАССА)) - заменяет один класс на другой
			
			
		.style - эффективный инструмент для изменения встроенных стилей элемента.Оно подходит для временных, уникальных изменений или простых анимаций, 
			в то время как для сложного или постоянного стайлинга лучше испольщовать CSS-классы
				ПРИМЕР ЗАПИСИ:			//место '-' используется заглавная буква 
					element.style.marginBottom = "30px"
					
					
		getComputedStyle() - мощный метод для получения реальных значений CSS - свойств элемента после их вычисления браузером.Это полезно для анализа 
			и динамического управления стилями, особенно при работе с анимациями и псевдоэлементами
		
		
		.hidden = true/false - скрывает элемент
			
			
			
			
		/////СОБЫТИЯ В JAVA SCRIPT\\\\\
		
			.onclick - это простой и быстрый способ назначить функцию на клик.
			.addEventListener(event, handler, options) - это гибкий метод позваляющий добавлять бработчики событий с расширеными возможностями управления
								event - тип события, например: "click","mouseover","keydown" и тд
								handler - функция обработчик, которая выполнятеся при возникновение события (function(){})
								options - необязательное а так это объект или булевое значение задающее параметры события, такие как once(выполнить только один раз) и тп
			.removeEventListner - удаляет событие
								
			
			
						function showConsole(event){
							console.log(event.type);
							console.log(event.target);
							console.log(event.currentTarget);
							console.log(event.clientX);
							console.log(event.clientY);
						}

						button.addEventListener("click", showConsole);
						
						.type - кароче как typeOf
						.target - указывает на элемент с котоырм произошло событие
						.event.currentTarget - указывает на элемент к которому привязан обработчик
						.clientX - Положение курсора по оси X
						.clientY - Положение курсора по оси Y		
			
			.preventDefualt() - используется для отмены стандартного поведения браузера при возникновение события
			
			///События мыши///
			//Простые события 
			mousedown / mouseup - Кнопка мыши нажата / отпущена над элементном 
			mouseover / mouseout - Курсор мыши появляется над элементом и ходит с него
			mousemove - Каждое движение мыши над элементом генерирует это событие
			contextmenu - Вызывается при попытке открытия контекстного меню, как правило нажатием правой кнопки мыши.
						  Но, заметим, это не совсем событие мыши, оно может вызываться и специальной клавишей клавиатуры
			mouseenter - срабатывает когда курсор входит в границы элемента
			mouseleave - срабатывает когда курсор покидает границу элемента
				В отличие от mouseover и mouseout они не считывают внутрение элементы элемента в  которой зашли или вышли 
				
				
			//Комплексные события
			click - Вызывается при mousedown, а затем mouseup над одним и тем же элементом, если использовалась основная кнопка мыши
			dblclock - Вызывается двойным кликом на элементе 
			Комплексные события состоят из простых
			
			///События клавиатуры///
			
			keydown - срабатывает когда клавиша на клавиатуре нажата
			keyup - срабатывает когда клавиша на клавиатуре отжата
			keyup - срабатывает когда клавиша на клавиатуре отжата
		
		
		DomContentLoaded - событие срабатывает когда всеь HTML был загружен и разобран но не обязательно все ресурсы(например иозображения стили скрипты)
			были загружены.Это событие является наиболее популярным дляв ыполнения кода, который зависит от структуры DOM, так как оно позволяет работать
			с элементами страницы сразу после их загрузки, не ожидая загрузки изображений и других внешних ресурсов
			
		Основные методы Math
1. Округление чисел

    Math.round(x) — округляет число x до ближайшего целого.

		console.log(Math.round(4.5)); // 5
		console.log(Math.round(4.4)); // 4

		Math.floor(x) — округляет число x вниз (в меньшую сторону).

		console.log(Math.floor(4.9)); // 4

		Math.ceil(x) — округляет число x вверх (в большую сторону).

		console.log(Math.ceil(4.1)); // 5

		Math.trunc(x) — удаляет дробную часть числа x.

			console.log(Math.trunc(4.9)); // 4

		2. Случайные числа

			Math.random() — возвращает случайное число в диапазоне от 0 (включительно) до 1 (не включительно).

		console.log(Math.random()); // Пример: 0.845093

		Генерация случайного числа в заданном диапазоне:

			function getRandomInt(min, max) {
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			console.log(getRandomInt(1, 10)); // Число от 1 до 10

		3. Возведение в степень и корни

			Math.pow(base, exponent) — возведение числа base в степень exponent.

				console.log(Math.pow(2, 3)); // 8 (2 в степени 3)

			С ES6 лучше использовать оператор **:

				console.log(2 ** 3); // 8

			Math.sqrt(x) — квадратный корень числа x.

				console.log(Math.sqrt(9)); // 3

			Math.cbrt(x) — кубический корень числа x.

				console.log(Math.cbrt(27)); // 3

		4. Минимум и максимум

			Math.min(a, b, c, ...) — возвращает наименьшее из переданных чисел.

				console.log(Math.min(1, 2, 3, -1)); // -1

			Math.max(a, b, c, ...) — возвращает наибольшее из переданных чисел.

				console.log(Math.max(1, 2, 3, -1)); // 3

		5. Тригонометрия

			Math.sin(x) — синус угла (в радианах).
			Math.cos(x) — косинус угла (в радианах).
			Math.tan(x) — тангенс угла (в радианах).

				Пример:
				console.log(Math.sin(Math.PI / 2)); // 1 (синус 90°)
				console.log(Math.cos(0)); // 1 (косинус 0°)

		6. Логарифмы

			Math.log(x) — натуральный логарифм числа x (основание e).

				console.log(Math.log(1)); // 0

				Math.log10(x) — логарифм по основанию 10.

				console.log(Math.log10(100)); // 2

				Math.log2(x) — логарифм по основанию 2.

					console.log(Math.log2(8)); // 3

		7. Абсолютное значение

			Math.abs(x) — возвращает абсолютное значение числа x (модуль числа).

				console.log(Math.abs(-5)); // 5

		Когда использовать Math?

			Генерация случайных чисел — игры, пароли, случайные цвета и т.д.
			Округление чисел — отображение цен, процентов и других данных.
			Тригонометрия — анимации, вычисления углов.
			Работа с логарифмами и степенями — вычисления в научных или финансовых приложениях.

		Полезные комбинации

			Генерация случайного целого числа:

		const randomInt = Math.floor(Math.random() * (max - min + 1)) + min;

		Округление числа до N знаков после запятой:

			function roundTo(num, decimals) {
				return Math.round(num * 10 ** decimals) / 10 ** decimals;
			}

			console.log(roundTo(3.141592, 2)); // 3.14

		Math — мощный инструмент, который широко используется во многих задачах, связанных с вычислениями в JavaScript.
		
			
	.cheсked - Проверяет выбран ли чекбокс или радиобутон
			
	//Работа со строками
	
		str.charAt(index) - метод выводит символ по указанному индексу
		str.indexOf(элемент) - метод выводит индекс первого вхождения индекса символа иначе вернет -1
		str.lastIndexOf(элемент) - метод выводит индекс последние вхождения индекса символа иначе вернет -1
		str.length - выведет размер строки
		str.trim - удаляет пробелы в начале и в конце
		str.repeat(число) - повтор строки число раз
		str.startsWith("символ,слово") - проверяет начинается ли строка с (символа, слова) и выводит true иначе false
		str.endsWith("символ/слово") - проверяет заканчивается ли строка с (символа, слова) и выводит true иначе false
		str.includes("символ/слово") - проверяет есть ли такой символо в строке и возвращает true иначе false
		str.replaceAll("заменяемый символ","символ замены") - заменяет все вхождения символа 
		str.padStart(число,"символ") - число это максимальный размер строки а "символ" это если строка меньша числа заполняет строку этим символом
		str.slice(первый индекс, второй индекс) - возвращает новую строку вырезаную из str по индексам чтобы начать с конца нужно использовать slice(-i)
		
		
	//Работа с массивами
	
		array.push(элемент) - добавляет один  или нескольно элементов в конец массива
		array.pop() - удаляет последний элемент массива и возвращает его
		array.unshift(элемент) - добавляет один или несколько элементов  в начало массива
		array.shift - удаялет первый элемент массива и возвращает его
		array.length - возвращает размер массива(длину)
		array.indexOf(элемент) - возвращает индекс первого вхождения элемента если элемента нет вернет -1
		
		 Простыми словами ... — это "распаковщик" или "собиратель", который может:
			Раскладывать содержимое массива или объекта.
			Представьте, что массив или объект — это коробка, а ... достаёт всё, что внутри, и "раскладывает" по местам.
			Собирать остатки данных в массив или объект.
				Если у вас есть несколько вещей, ... соберёт их в одну коробку.
				
				
	Callback — это функция, переданная в другую функцию для выполнения после определённой операции. 
		Они широко используются для асинхронных операций и предоставляют большую гибкость, 
		но для сложных случаев лучше использовать Promises или async/await.
		
	forEach выполняет указанную функцию для каждого элемента массива, но ничего не возвращает.
	
	map выполняет функцию для каждого элемента и возвращает новый массив с результатами выполнения функции.
		Отличие между forEach и map в том что forEach меняет миссив а map возвращает новый
		
	split метод строки который делет строку с помощью указанного элемента разделителя и возвращате массив элементов  
			Пример: str = "qwe, asd, zxc"
					str = str.split(", ")
					console.log(str) // Вывод: ["qwe","asd","zxc"]
					
	filter() - метод возврашает  новый массив из элементов которые подходят заданному условию 
	
	reduce() - метод возвращает одно число которое считается из элементов массива
	
	Объект в js это стурктура данных, которая позволяет хранить набор связанных данных(свойств) и функций(методов). Объекты являеются основой больщинства 
		функциональностей js
		Объект это коробка со свойствами - данные
							и методами - функции
							
	this в js это ключевое слова, которое указывает на текущий контекст выполнения. Другими словами, это объект к которому функция или метод были привязаны в моменте выозова.
	
	Функция конструктор - это шаблон для создания объекта.Они исопльщуются для упрощения создания множества однотиных объектов. Вместо того чтобы каждый раз вручную 
		задавать свойства объекта, конструктор позваляет автоматизировать этот процесс.Но сейчас актуальнее пользоваться классами
		
	Классы в js это синтаксическая обертка для работы с объектами и их прототипами. Они появились в ES6 и позволяют создавать объекты и определять их поведение 
		в более удобной и структурированной форме
		
	Сам класс - это шаблон для создания объектов. Он содержит свойства и методы, которые описывают поведение этих объектов
		Классы в js помогают организовать код более структурированно, что особенно полезно в больших проектах. Это современный подход к созданию объектов 
			и их взаимодействию. Если работа с объектами, которые должны иметь свойства и методы, испольщование класс - это предпочтительный способ
			
	///Пример класса////
		class Product{
			constructor(name,price){
				this.name = name;
				this.price = price;
			}
			displayProduct(){
				console.log(`Продукт: ${this.name}`);
				console.log(`Цена: ${this.price}р.`);
			}
		}

		const product1 = new Product("Гойда", 199);
		product1.displayProduct();
		
	Ключевое слово static в js используется для создания статических методов или свойств в классе. Такие методы и своойства принадлежат классу, а не его экземлярам.
		Это означает что можно вызвать их напрямаю через класс, без создания объекта(экземпляра) класса.
		
	Ключевое слово extends в JavaScript используется для наследования в классах. 
		Оно позволяет одному классу (называемому производным классом) 
		унаследовать свойства и методы другого класса (называемого базовым классом)
		
	В JavaScript super используется в классах и служит для обращения к родительскому классу (суперклассу). 
		Он позволяет вызывать методы или конструктор родительского класса внутри дочернего.
		
	super — мощный инструмент для работы с наследованием в JavaScript. Он позволяет делать ваш код более модульным и переиспользуемым.
	
	get и set это специальные методы доступа, которые позволяют управлять получением и устанвокой значений свойств объектов. Они определяются внутри классов или объектов
		и предоставляют более контролируемый способ взаимодействия с данными 
	
			get - используется для получения значения свойства. Он позволяет задать метод, который будет вызвываться при доступе к свойству
			set - используется для установки значения свойств. Он позваляет задать метод, который будет вызываться при присвоении значения свойству
				
				Когда использовать get и set?
					get и set это мощные инстурменты для работы с объектами и классами, позволяющие скрывать реализацию внутренней логики и добавлять проверки 
						при чтении и записи данных.
	
	Деструктуризация в js это удобный способ извлечения значений из массивов или объектов и присваивания их переменным. 
		Вместо того чтобы обращаться к элементам или свойствам вручную, можно исопльзовать краткую запись.
		
			///Пример 1///
				let a = 1;
				let b = 2;

				[a,b] = [b,a];

				console.log(a); // Вывод: 2
				console.log(b); // Вывод: 1
			
			///Пример 2 ///(Меняем местами первый и последний объект массива)
				const colors = ["red","green","blue","white"];

				[colors[0],colors[3]] = [colors[3],colors[0]];

				console.log(colors);
				
			///Пример 3///
				const colors = ["red","green","blue","white"];

				const [firstColor,secondColor, ...extraColors] = colors; //Присвоение значений массива к переменным
				console.log(firstColor); //Вывод: red
				console.log(extraColors); //Вывод: [blue,white] (...exxtraColors выводит массив из остальных элеменетов массива)
				
			///Пример 4///
				function displayPerson({name,age,isAlive}){ //деструткутризация происходит в  функции 
				console.log(`Имя: ${name}`);
				console.log(`Возраст: ${age}`);
				console.log(`Жив?: ${isAlive}`);
				}

				const perosn1 = {
					name: "iou",
					age: 52,
					isAlive: true
				};

				const perosn2 = {
					name: "uoi",
					age: 25,
					isAlive: false
				};

				displayPerson(perosn1)
					Кароче деструктуризация это присваивание переменным  значений  из массивов либо объекетов
					
	
	Вложенные объекты это структура, где один объект содержит другой объект в качестве значения своего свойства.
		Они позволяют создавать сложные иерархические данные и организовывать их удобным образом
		
	Массивы объектов в js это массив, где каждый элемент является объектом. Они используются для стурктурирования и работы с большими наборами связанных данных
		например, данными о пользователях, товарах, заказах и т.данные
		
		//Пример записи//
		const fruits =  <--- Массив объектов
		[
			{name:"Яблоко", color: "red"}, 
			{name:"Груша", color: "green"}
		]

		for (const fruit of fruits) <---- цикл для перебора объектов массива
		{
			console.log(fruit.name);
		}
		
		
		
		
	for...of используется для работы с значениями массива.
	for...in или .forEach() удобны, если нужны индексы.
	
	Метод sort в js используется для сортировки элементов массива на месте(то есть исходный массив изменяется) и возвращается этот массив 
	
		//Пример записи для букввеного массива///
			let fruits = ["Банан","Арбуз","Виноград"];
			fruits.sort();
			console.log(fruits);
			
		//Пример записи для циферного массива///
			let numbers = [2,44,11,33,1,5,4,7];
			numbers.sort((a,b)=>a-b) // a-b - от меньшего к болльшему
										b-a - от большего к меньшему
			console.log(numbers)
		
	Так же метод sort() можно применять к массивам объектов 
		//Пример//
		const people =
		[
			{name:"Сашка",age: 52},
			{name:"Сашка1",age: 19},
			{name:"Сашка2",age: 13} 
		]
		people.sort((a,b)=> a.age - b.age) <--- Сортировка по возрасту от меньшего к большему 

		console.log(people); //Вывод: 0: {name: 'Сашка2', age: 13}
									  1:{name: 'Сашка1', age: 19}
									  2: {name: 'Сашка', age: 52}
									  
		
		Шафл в js:
		
		function shuffle(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		return array;
		}
		
		в JS объект Date ипользуется для работы с датой и временем. Он предоставляет множество методов для получения, установки и преобразования дат и времени
		
		Параметры записи:Date(year: number, monthIndex: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number)
		
		///Текущая дата и время: const now = new Date();
								 console.log(now)
		
		//Свое время и дата: const date = new Date(2023,11,05);
						 	 console.log(date) //Вывод:Tue Dec 05 2023 00:00:00 GMT+0300 (Москва, стандартное время)
							 
		//С указанием времени: const specificDateTime = new Date(2024, 11, 25, 15, 30, 45);
							   console.log(specificDateTime); //Вывод: Wed Dec 25 2024 15:30:45 GMT+0300 (Москва, стандартное время)
							   
		//Из строки: const fromString = new Date("2024-12-25T15:30:00");
					 console.log(fromString) //Вывод: Wed Dec 25 2024 15:30:00 GMT+0300 (Москва, стандартное время)
					 
		//Через метки времени (миллисекунды с 1970 года): const fromTimestamp = new Date(1672531200000);
														  console.log(fromTimestamp); //Вывод: Sun Jan 01 2023 03:00:00 GMT+0300 (Москва, стандартное время)
														  
		/////Разница между строковой записью и обычной в том что в строке ипользуется месяц по числу а в обычной по индексу

		
		Методы Date:
		Метод getFullYear возвращает год даты 
		Метод getMonth возвращает месяц даты 
		Метод getDate возвращает день даты 
		Метод getDay возвращает день недели 
		Методы getHours(), getMinutes(), getSeconds(), getMilliseconds() — возвращают соответствующие части времени.
		Метод getTime() — возвращает количество миллисекунд с 1 января 1970 года.
		Метод setFullYear - Устанавливает год  (кароче все также как с get только за место get пишется set)
		
		
		Замыкание в js - это механизм, который позваляет вложенной функции запомнить и использовать переменные из функции 
			даже после того, как внешняя функция завершила выполнения
		
		
		
		Затворы --- это механизм синхронизации в многопоточном или асинхроном программировании. Затворы используются для управления доступом к рессурсам,
			чтобы избежать конфликтов, например, когда два потока пытаются одновременно изменить одни и те же данные.

				Пример ситуации с затвором:
					Один поток записывает данные в файл а другой в этот момент пытается их читать.
					Чтобы избежать ошибок, используется затвор, который блокирует доступ ко времени завершения операции.
					
		setTimeout - встроенная функция в js которая используется для выполнения кода или вызова функции с задержкой во времени.
		
		Синтаксис: setTimeout(function, delay, param1,param2, ...)
												function - функция, которую нужно выполнить 
												delay - задержка в миллисекундах 
												param1,param2 - (опционально) параметры, которые передаются в функцию.
		
		clearTimeout - встроенная функция в js, которая омтеняет выполнения функции, ранее запланированной с помощью setTimeout
		
		Синтаксис: clearTimeout(timeoutID)
							timeoutID - идентификатор таймера, возвращаемый функцией setTimeout
							timeoutID - идентификатор таймера, возвращаемый функцией setTimeout
							
		setInterval - метод в js который позволяет выполнять функцию или ктор через заданные интервалы времени (в миллисекундах)
		
		Синтаксис: const intervalID = setInterval(callback, delay, [arg1, arg2, ...]);
															callback — Функция, которая будет выполняться на каждом интервале.
															delay — Задержка в миллисекундах между выполнениями функции.
															arg1, arg2, ... (необязательно) — Дополнительные аргументы, которые передаются в функцию callback.
															intervalID — Уникальный идентификатор таймера, который можно использовать для остановки интервала с помощью clearInterval.
															
															
		ES6 Modules это стандартный способ организации и использования модулей в js представленный в спецификации ECMAScript 2015(ES6). Они помогают разбивать код на более мелкие части,
			чтобы сделать его более читаемым, удобным для поддержки и повторно использовать.
		
		Основные особенности модулей ES6:
			1.Каждый модуль - это файл.
				В js модуль это отдельный файл. Все что экспортируется из этого файфла, может быть использованно в других файлах
			
			2.export - для экспорта данных или функций.
				Данные, функции, классы или другие сущности из модуля нужно экспортировать, чтобы они стали доступными для других файлов
				
			3.import - для импорта данных или функций 
				Для использования данных или функций из другого модуля их нужно импортировать
				
			Синхронное и асинхронное программирование в js относятся к способу выполнения кода и управления задачами, которые могут занять некоторое время, например, обращения к серверу или чтения файл.
			
			Синхронное выполнение 
				Как работает: Код выполняется построчно, сверху вниз. Следующая строчка не начнет выполняться, пока текущая не завершится.
					Особенности:
						Простой порядок выполнения.
						Если одна задача занимает много времени (например, сложные вычисления), весь код "Останавливается" до ее завершения.
							Пример синхронного кода:
								console.log("Начало");

								function add(a, b) {
									return a + b;
								}
								const result = add(5, 3);
								console.log("Результат:", result);

								console.log("Конец");
								// Вывод:
								// "Начало"
								// "Результат: 8"
								// "Конец"
								
			Асинхронное выполнение
				Как работает: Некоторые операции (например, запрос к серверу) могут быть выполнены в фоне, не блокируя основной поток выполнения. Код продолжает выполняться, а результатами	
					асинхронной операции обрабатывается позже.
						Особенности:
							Асинхроность позволяет js быть "неблокирующим", что особенно важно для работы в браузере.
							Асинхронные задачи часто ипользуют обещания(promises) или обратные вызовы(callbacks)
								Пример асинхронного кода:
									console.log("Начало");

									setTimeout(() => {
										console.log("Асинхронная операция завершена");
									}, 2000);

									console.log("Конец");
									// Вывод:
									// "Начало"
									// "Конец"
									// (Через 2 секунды) "Асинхронная операция завершена"
									
										Когда использовать асинхронность:
											Асинхронность полезна в задачах которые занимают много времени такие как:
												Запросы к серверу
												Работа с файлами или базами данных
												Таймеры
												Анимация и пользовательские события 
												
				Обработка ошибок в js  с  помощью конструкции try... catch... finally позволяет безопасно выолнять код, обрабатывать возможные ошибки и завершить выполнение независимо 
					от того возникла ошибка или нет
						try - в этом блоке размещается код, котоырй может вызвать ошибку
						catch - обрабатывает ошибку, если она произошла в блоке try
						finally(опционально) - блок, который выполняется в любом случае (независимо от наличия ошибок)
						
						Пример добавления свой ошибки:
							if(dividend < 0 || divisor < 0){
							throw new Error("Данные не могут быть меньше 0")
							}
							
			eval - встроенная функция в js которая выолняет строку кода как js Если в строке содержится выражение, оно вычисляет а результат возвращает
			
			Навигация по DOM в js - возможность перемещаться по элементам веб-страницы через дерево DOM. DOM(Document Object Model) представляет структуру HTML-документа как дерево узлов
				Основные ущлы DOM:
				1.Элемент - тег HTML(<div>,<p>,<h> и т д)
				2.Текстовый узел - текст внутри элемента
				3.Документ - корневой объект всего DOM
				4.Атрибуты - атрибуты элементов
				
			Способы навигация по DOM
				1.firstElementChild - Возвращает первый дочерний элемент родителя
				2.lastElementChild - Возвращает последний дочерний элемент родителя
				3.nextElementSibling - Возвращает соседний элемент на том же уровне в DOM
				4.perviousElementSibling
				5.parentElement - Возвращает родительский элемент текущего узла
				6.children - Возвращает HTMLColection всех дочерних элементов 
				7.childNodes - возвращает все дочерние узлы 
				
				
			Добавление и изменения элементов DOM Через js  --- одна из основных задач веб-разработки. С помощью js модно динамически создавать элементы, изменять их содержимое и атрибуты 
				а также вставлять их в нужные места на странице			
				
				JSON - это текстовый формат данных, который используется для передачи данных между сервером и клиентом или для хранения данных. Он прост для чтения и написания как людям
					так и машинам. JSON часто используется в веб-разработки благодаря своей универсальности и легкости.
					
				JSON - это не код, а строка, которая представляет данные в формате ключ-значение.
				По структуре  JSON похож на объекты в js, но это строковое представление.
				Он независим от языков программирования, поэтому может использоваться не только в JS, но и в Phyton, Java, PHP и других языках 
				
				JSON и JS
					Преобразование JSON в объект JS (JSON.parse)
					Метод JSON.parse используется для преобразования JSON-строки в js-объект 
					
				
					Преобразование объекта в JSON-строку(JSON.stringify)
					Метод JSON.stringify используется для преобразования объекта JS в JSON-Сстроку
					
					По итогу JSON это простой и удобный формат для обмена и хранения данных. Его основные преимущества:
						1. Простота: легко читать и писать
						2. Совместимость: поддерживается во всех языках программирования 
						3. Легкость: компактный и быстрый формат 